// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: matches.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countMatches = `-- name: CountMatches :one
SELECT COUNT(*) FROM matches
WHERE deleted_at IS NULL
`

func (q *Queries) CountMatches(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countMatches)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMatchesByTeam = `-- name: CountMatchesByTeam :one
SELECT COUNT(*) FROM matches
WHERE (home_team_id = $1 OR away_team_id = $1) AND deleted_at IS NULL
`

func (q *Queries) CountMatchesByTeam(ctx context.Context, homeTeamID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countMatchesByTeam, homeTeamID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMatch = `-- name: CreateMatch :one
INSERT INTO matches (
    home_team_id, away_team_id, match_date, competition, season, round,
    stadium, attendance, status, referee, home_team_score, away_team_score
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, home_team_id, away_team_id, match_date, competition, season, round, stadium, attendance, status, referee, home_team_score, away_team_score, created_at, updated_at, deleted_at
`

type CreateMatchParams struct {
	HomeTeamID    int32              `json:"home_team_id"`
	AwayTeamID    int32              `json:"away_team_id"`
	MatchDate     pgtype.Timestamptz `json:"match_date"`
	Competition   string             `json:"competition"`
	Season        string             `json:"season"`
	Round         *string            `json:"round"`
	Stadium       *string            `json:"stadium"`
	Attendance    *int32             `json:"attendance"`
	Status        string             `json:"status"`
	Referee       *string            `json:"referee"`
	HomeTeamScore int32              `json:"home_team_score"`
	AwayTeamScore int32              `json:"away_team_score"`
}

func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) (Match, error) {
	row := q.db.QueryRow(ctx, createMatch,
		arg.HomeTeamID,
		arg.AwayTeamID,
		arg.MatchDate,
		arg.Competition,
		arg.Season,
		arg.Round,
		arg.Stadium,
		arg.Attendance,
		arg.Status,
		arg.Referee,
		arg.HomeTeamScore,
		arg.AwayTeamScore,
	)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.MatchDate,
		&i.Competition,
		&i.Season,
		&i.Round,
		&i.Stadium,
		&i.Attendance,
		&i.Status,
		&i.Referee,
		&i.HomeTeamScore,
		&i.AwayTeamScore,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteMatch = `-- name: DeleteMatch :exec
UPDATE matches
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteMatch(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteMatch, id)
	return err
}

const getLiveMatches = `-- name: GetLiveMatches :many
SELECT id, home_team_id, away_team_id, match_date, competition, season, round, stadium, attendance, status, referee, home_team_score, away_team_score, created_at, updated_at, deleted_at FROM matches
WHERE status = 'live' AND deleted_at IS NULL
ORDER BY match_date DESC
`

func (q *Queries) GetLiveMatches(ctx context.Context) ([]Match, error) {
	rows, err := q.db.Query(ctx, getLiveMatches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Match{}
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.MatchDate,
			&i.Competition,
			&i.Season,
			&i.Round,
			&i.Stadium,
			&i.Attendance,
			&i.Status,
			&i.Referee,
			&i.HomeTeamScore,
			&i.AwayTeamScore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchByID = `-- name: GetMatchByID :one
SELECT id, home_team_id, away_team_id, match_date, competition, season, round, stadium, attendance, status, referee, home_team_score, away_team_score, created_at, updated_at, deleted_at FROM matches
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetMatchByID(ctx context.Context, id int32) (Match, error) {
	row := q.db.QueryRow(ctx, getMatchByID, id)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.MatchDate,
		&i.Competition,
		&i.Season,
		&i.Round,
		&i.Stadium,
		&i.Attendance,
		&i.Status,
		&i.Referee,
		&i.HomeTeamScore,
		&i.AwayTeamScore,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getMatchWithTeams = `-- name: GetMatchWithTeams :one
SELECT
    m.id, m.home_team_id, m.away_team_id, m.match_date, m.competition, m.season, m.round, m.stadium, m.attendance, m.status, m.referee, m.home_team_score, m.away_team_score, m.created_at, m.updated_at, m.deleted_at,
    ht.id as home_team_id,
    ht.name as home_team_name,
    ht.short_name as home_team_short_name,
    ht.code as home_team_code,
    ht.logo as home_team_logo,
    at.id as away_team_id,
    at.name as away_team_name,
    at.short_name as away_team_short_name,
    at.code as away_team_code,
    at.logo as away_team_logo
FROM matches m
LEFT JOIN teams ht ON m.home_team_id = ht.id AND ht.deleted_at IS NULL
LEFT JOIN teams at ON m.away_team_id = at.id AND at.deleted_at IS NULL
WHERE m.id = $1 AND m.deleted_at IS NULL
LIMIT 1
`

type GetMatchWithTeamsRow struct {
	ID                int32              `json:"id"`
	HomeTeamID        int32              `json:"home_team_id"`
	AwayTeamID        int32              `json:"away_team_id"`
	MatchDate         pgtype.Timestamptz `json:"match_date"`
	Competition       string             `json:"competition"`
	Season            string             `json:"season"`
	Round             *string            `json:"round"`
	Stadium           *string            `json:"stadium"`
	Attendance        *int32             `json:"attendance"`
	Status            string             `json:"status"`
	Referee           *string            `json:"referee"`
	HomeTeamScore     int32              `json:"home_team_score"`
	AwayTeamScore     int32              `json:"away_team_score"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
	HomeTeamID_2      *int32             `json:"home_team_id_2"`
	HomeTeamName      *string            `json:"home_team_name"`
	HomeTeamShortName *string            `json:"home_team_short_name"`
	HomeTeamCode      *string            `json:"home_team_code"`
	HomeTeamLogo      *string            `json:"home_team_logo"`
	AwayTeamID_2      *int32             `json:"away_team_id_2"`
	AwayTeamName      *string            `json:"away_team_name"`
	AwayTeamShortName *string            `json:"away_team_short_name"`
	AwayTeamCode      *string            `json:"away_team_code"`
	AwayTeamLogo      *string            `json:"away_team_logo"`
}

func (q *Queries) GetMatchWithTeams(ctx context.Context, id int32) (GetMatchWithTeamsRow, error) {
	row := q.db.QueryRow(ctx, getMatchWithTeams, id)
	var i GetMatchWithTeamsRow
	err := row.Scan(
		&i.ID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.MatchDate,
		&i.Competition,
		&i.Season,
		&i.Round,
		&i.Stadium,
		&i.Attendance,
		&i.Status,
		&i.Referee,
		&i.HomeTeamScore,
		&i.AwayTeamScore,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.HomeTeamID_2,
		&i.HomeTeamName,
		&i.HomeTeamShortName,
		&i.HomeTeamCode,
		&i.HomeTeamLogo,
		&i.AwayTeamID_2,
		&i.AwayTeamName,
		&i.AwayTeamShortName,
		&i.AwayTeamCode,
		&i.AwayTeamLogo,
	)
	return i, err
}

const getMatchesByCompetition = `-- name: GetMatchesByCompetition :many
SELECT id, home_team_id, away_team_id, match_date, competition, season, round, stadium, attendance, status, referee, home_team_score, away_team_score, created_at, updated_at, deleted_at FROM matches
WHERE competition = $1 AND deleted_at IS NULL
ORDER BY match_date DESC
LIMIT $2 OFFSET $3
`

type GetMatchesByCompetitionParams struct {
	Competition string `json:"competition"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

func (q *Queries) GetMatchesByCompetition(ctx context.Context, arg GetMatchesByCompetitionParams) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatchesByCompetition, arg.Competition, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Match{}
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.MatchDate,
			&i.Competition,
			&i.Season,
			&i.Round,
			&i.Stadium,
			&i.Attendance,
			&i.Status,
			&i.Referee,
			&i.HomeTeamScore,
			&i.AwayTeamScore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesByCompetitionAndSeason = `-- name: GetMatchesByCompetitionAndSeason :many
SELECT id, home_team_id, away_team_id, match_date, competition, season, round, stadium, attendance, status, referee, home_team_score, away_team_score, created_at, updated_at, deleted_at FROM matches
WHERE competition = $1 AND season = $2 AND deleted_at IS NULL
ORDER BY match_date DESC
`

type GetMatchesByCompetitionAndSeasonParams struct {
	Competition string `json:"competition"`
	Season      string `json:"season"`
}

func (q *Queries) GetMatchesByCompetitionAndSeason(ctx context.Context, arg GetMatchesByCompetitionAndSeasonParams) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatchesByCompetitionAndSeason, arg.Competition, arg.Season)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Match{}
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.MatchDate,
			&i.Competition,
			&i.Season,
			&i.Round,
			&i.Stadium,
			&i.Attendance,
			&i.Status,
			&i.Referee,
			&i.HomeTeamScore,
			&i.AwayTeamScore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesBySeason = `-- name: GetMatchesBySeason :many
SELECT id, home_team_id, away_team_id, match_date, competition, season, round, stadium, attendance, status, referee, home_team_score, away_team_score, created_at, updated_at, deleted_at FROM matches
WHERE season = $1 AND deleted_at IS NULL
ORDER BY match_date DESC
LIMIT $2 OFFSET $3
`

type GetMatchesBySeasonParams struct {
	Season string `json:"season"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetMatchesBySeason(ctx context.Context, arg GetMatchesBySeasonParams) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatchesBySeason, arg.Season, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Match{}
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.MatchDate,
			&i.Competition,
			&i.Season,
			&i.Round,
			&i.Stadium,
			&i.Attendance,
			&i.Status,
			&i.Referee,
			&i.HomeTeamScore,
			&i.AwayTeamScore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesByStatus = `-- name: GetMatchesByStatus :many
SELECT id, home_team_id, away_team_id, match_date, competition, season, round, stadium, attendance, status, referee, home_team_score, away_team_score, created_at, updated_at, deleted_at FROM matches
WHERE status = $1 AND deleted_at IS NULL
ORDER BY match_date DESC
LIMIT $2 OFFSET $3
`

type GetMatchesByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetMatchesByStatus(ctx context.Context, arg GetMatchesByStatusParams) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatchesByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Match{}
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.MatchDate,
			&i.Competition,
			&i.Season,
			&i.Round,
			&i.Stadium,
			&i.Attendance,
			&i.Status,
			&i.Referee,
			&i.HomeTeamScore,
			&i.AwayTeamScore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesByTeam = `-- name: GetMatchesByTeam :many
SELECT id, home_team_id, away_team_id, match_date, competition, season, round, stadium, attendance, status, referee, home_team_score, away_team_score, created_at, updated_at, deleted_at FROM matches
WHERE (home_team_id = $1 OR away_team_id = $1)
  AND deleted_at IS NULL
ORDER BY match_date DESC
LIMIT $2 OFFSET $3
`

type GetMatchesByTeamParams struct {
	HomeTeamID int32 `json:"home_team_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) GetMatchesByTeam(ctx context.Context, arg GetMatchesByTeamParams) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatchesByTeam, arg.HomeTeamID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Match{}
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.MatchDate,
			&i.Competition,
			&i.Season,
			&i.Round,
			&i.Stadium,
			&i.Attendance,
			&i.Status,
			&i.Referee,
			&i.HomeTeamScore,
			&i.AwayTeamScore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpcomingMatches = `-- name: GetUpcomingMatches :many
SELECT id, home_team_id, away_team_id, match_date, competition, season, round, stadium, attendance, status, referee, home_team_score, away_team_score, created_at, updated_at, deleted_at FROM matches
WHERE match_date > NOW() AND status = 'scheduled' AND deleted_at IS NULL
ORDER BY match_date ASC
LIMIT $1
`

func (q *Queries) GetUpcomingMatches(ctx context.Context, limit int32) ([]Match, error) {
	rows, err := q.db.Query(ctx, getUpcomingMatches, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Match{}
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.MatchDate,
			&i.Competition,
			&i.Season,
			&i.Round,
			&i.Stadium,
			&i.Attendance,
			&i.Status,
			&i.Referee,
			&i.HomeTeamScore,
			&i.AwayTeamScore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMatches = `-- name: ListMatches :many
SELECT id, home_team_id, away_team_id, match_date, competition, season, round, stadium, attendance, status, referee, home_team_score, away_team_score, created_at, updated_at, deleted_at FROM matches
WHERE deleted_at IS NULL
ORDER BY match_date DESC
LIMIT $1 OFFSET $2
`

type ListMatchesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListMatches(ctx context.Context, arg ListMatchesParams) ([]Match, error) {
	rows, err := q.db.Query(ctx, listMatches, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Match{}
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.MatchDate,
			&i.Competition,
			&i.Season,
			&i.Round,
			&i.Stadium,
			&i.Attendance,
			&i.Status,
			&i.Referee,
			&i.HomeTeamScore,
			&i.AwayTeamScore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMatch = `-- name: UpdateMatch :one
UPDATE matches
SET
    match_date = COALESCE($1, match_date),
    competition = COALESCE($2, competition),
    season = COALESCE($3, season),
    round = COALESCE($4, round),
    stadium = COALESCE($5, stadium),
    attendance = COALESCE($6, attendance),
    status = COALESCE($7, status),
    referee = COALESCE($8, referee),
    home_team_score = COALESCE($9, home_team_score),
    away_team_score = COALESCE($10, away_team_score)
WHERE id = $11 AND deleted_at IS NULL
RETURNING id, home_team_id, away_team_id, match_date, competition, season, round, stadium, attendance, status, referee, home_team_score, away_team_score, created_at, updated_at, deleted_at
`

type UpdateMatchParams struct {
	MatchDate     pgtype.Timestamptz `json:"match_date"`
	Competition   *string            `json:"competition"`
	Season        *string            `json:"season"`
	Round         *string            `json:"round"`
	Stadium       *string            `json:"stadium"`
	Attendance    *int32             `json:"attendance"`
	Status        *string            `json:"status"`
	Referee       *string            `json:"referee"`
	HomeTeamScore *int32             `json:"home_team_score"`
	AwayTeamScore *int32             `json:"away_team_score"`
	ID            int32              `json:"id"`
}

func (q *Queries) UpdateMatch(ctx context.Context, arg UpdateMatchParams) (Match, error) {
	row := q.db.QueryRow(ctx, updateMatch,
		arg.MatchDate,
		arg.Competition,
		arg.Season,
		arg.Round,
		arg.Stadium,
		arg.Attendance,
		arg.Status,
		arg.Referee,
		arg.HomeTeamScore,
		arg.AwayTeamScore,
		arg.ID,
	)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.MatchDate,
		&i.Competition,
		&i.Season,
		&i.Round,
		&i.Stadium,
		&i.Attendance,
		&i.Status,
		&i.Referee,
		&i.HomeTeamScore,
		&i.AwayTeamScore,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateMatchScore = `-- name: UpdateMatchScore :one
UPDATE matches
SET
    home_team_score = $2,
    away_team_score = $3
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, home_team_id, away_team_id, match_date, competition, season, round, stadium, attendance, status, referee, home_team_score, away_team_score, created_at, updated_at, deleted_at
`

type UpdateMatchScoreParams struct {
	ID            int32 `json:"id"`
	HomeTeamScore int32 `json:"home_team_score"`
	AwayTeamScore int32 `json:"away_team_score"`
}

func (q *Queries) UpdateMatchScore(ctx context.Context, arg UpdateMatchScoreParams) (Match, error) {
	row := q.db.QueryRow(ctx, updateMatchScore, arg.ID, arg.HomeTeamScore, arg.AwayTeamScore)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.MatchDate,
		&i.Competition,
		&i.Season,
		&i.Round,
		&i.Stadium,
		&i.Attendance,
		&i.Status,
		&i.Referee,
		&i.HomeTeamScore,
		&i.AwayTeamScore,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateMatchStatus = `-- name: UpdateMatchStatus :one
UPDATE matches
SET status = $2
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, home_team_id, away_team_id, match_date, competition, season, round, stadium, attendance, status, referee, home_team_score, away_team_score, created_at, updated_at, deleted_at
`

type UpdateMatchStatusParams struct {
	ID     int32  `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateMatchStatus(ctx context.Context, arg UpdateMatchStatusParams) (Match, error) {
	row := q.db.QueryRow(ctx, updateMatchStatus, arg.ID, arg.Status)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.MatchDate,
		&i.Competition,
		&i.Season,
		&i.Round,
		&i.Stadium,
		&i.Attendance,
		&i.Status,
		&i.Referee,
		&i.HomeTeamScore,
		&i.AwayTeamScore,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
