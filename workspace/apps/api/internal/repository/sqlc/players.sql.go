// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: players.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPlayers = `-- name: CountPlayers :one
SELECT COUNT(*) FROM players
WHERE deleted_at IS NULL
`

func (q *Queries) CountPlayers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPlayers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPlayersByTeam = `-- name: CountPlayersByTeam :one
SELECT COUNT(*) FROM players
WHERE team_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountPlayersByTeam(ctx context.Context, teamID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countPlayersByTeam, teamID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPlayer = `-- name: CreatePlayer :one
INSERT INTO players (
    team_id, first_name, last_name, full_name, date_of_birth, nationality,
    position, shirt_number, height, weight, preferred_foot, photo
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, team_id, first_name, last_name, full_name, date_of_birth, nationality, position, shirt_number, height, weight, preferred_foot, photo, created_at, updated_at, deleted_at
`

type CreatePlayerParams struct {
	TeamID        int32       `json:"team_id"`
	FirstName     string      `json:"first_name"`
	LastName      string      `json:"last_name"`
	FullName      string      `json:"full_name"`
	DateOfBirth   pgtype.Date `json:"date_of_birth"`
	Nationality   *string     `json:"nationality"`
	Position      string      `json:"position"`
	ShirtNumber   *int32      `json:"shirt_number"`
	Height        *int32      `json:"height"`
	Weight        *int32      `json:"weight"`
	PreferredFoot *string     `json:"preferred_foot"`
	Photo         *string     `json:"photo"`
}

func (q *Queries) CreatePlayer(ctx context.Context, arg CreatePlayerParams) (Player, error) {
	row := q.db.QueryRow(ctx, createPlayer,
		arg.TeamID,
		arg.FirstName,
		arg.LastName,
		arg.FullName,
		arg.DateOfBirth,
		arg.Nationality,
		arg.Position,
		arg.ShirtNumber,
		arg.Height,
		arg.Weight,
		arg.PreferredFoot,
		arg.Photo,
	)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.FirstName,
		&i.LastName,
		&i.FullName,
		&i.DateOfBirth,
		&i.Nationality,
		&i.Position,
		&i.ShirtNumber,
		&i.Height,
		&i.Weight,
		&i.PreferredFoot,
		&i.Photo,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deletePlayer = `-- name: DeletePlayer :exec
UPDATE players
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeletePlayer(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deletePlayer, id)
	return err
}

const getPlayerByID = `-- name: GetPlayerByID :one
SELECT id, team_id, first_name, last_name, full_name, date_of_birth, nationality, position, shirt_number, height, weight, preferred_foot, photo, created_at, updated_at, deleted_at FROM players
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetPlayerByID(ctx context.Context, id int32) (Player, error) {
	row := q.db.QueryRow(ctx, getPlayerByID, id)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.FirstName,
		&i.LastName,
		&i.FullName,
		&i.DateOfBirth,
		&i.Nationality,
		&i.Position,
		&i.ShirtNumber,
		&i.Height,
		&i.Weight,
		&i.PreferredFoot,
		&i.Photo,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPlayerWithTeam = `-- name: GetPlayerWithTeam :one
SELECT
    p.id, p.team_id, p.first_name, p.last_name, p.full_name, p.date_of_birth, p.nationality, p.position, p.shirt_number, p.height, p.weight, p.preferred_foot, p.photo, p.created_at, p.updated_at, p.deleted_at,
    t.id as team_id,
    t.name as team_name,
    t.short_name as team_short_name,
    t.code as team_code
FROM players p
LEFT JOIN teams t ON p.team_id = t.id AND t.deleted_at IS NULL
WHERE p.id = $1 AND p.deleted_at IS NULL
LIMIT 1
`

type GetPlayerWithTeamRow struct {
	ID            int32              `json:"id"`
	TeamID        int32              `json:"team_id"`
	FirstName     string             `json:"first_name"`
	LastName      string             `json:"last_name"`
	FullName      string             `json:"full_name"`
	DateOfBirth   pgtype.Date        `json:"date_of_birth"`
	Nationality   *string            `json:"nationality"`
	Position      string             `json:"position"`
	ShirtNumber   *int32             `json:"shirt_number"`
	Height        *int32             `json:"height"`
	Weight        *int32             `json:"weight"`
	PreferredFoot *string            `json:"preferred_foot"`
	Photo         *string            `json:"photo"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	DeletedAt     pgtype.Timestamptz `json:"deleted_at"`
	TeamID_2      *int32             `json:"team_id_2"`
	TeamName      *string            `json:"team_name"`
	TeamShortName *string            `json:"team_short_name"`
	TeamCode      *string            `json:"team_code"`
}

func (q *Queries) GetPlayerWithTeam(ctx context.Context, id int32) (GetPlayerWithTeamRow, error) {
	row := q.db.QueryRow(ctx, getPlayerWithTeam, id)
	var i GetPlayerWithTeamRow
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.FirstName,
		&i.LastName,
		&i.FullName,
		&i.DateOfBirth,
		&i.Nationality,
		&i.Position,
		&i.ShirtNumber,
		&i.Height,
		&i.Weight,
		&i.PreferredFoot,
		&i.Photo,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TeamID_2,
		&i.TeamName,
		&i.TeamShortName,
		&i.TeamCode,
	)
	return i, err
}

const getPlayersByPosition = `-- name: GetPlayersByPosition :many
SELECT id, team_id, first_name, last_name, full_name, date_of_birth, nationality, position, shirt_number, height, weight, preferred_foot, photo, created_at, updated_at, deleted_at FROM players
WHERE position = $1 AND deleted_at IS NULL
ORDER BY full_name
LIMIT $2 OFFSET $3
`

type GetPlayersByPositionParams struct {
	Position string `json:"position"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) GetPlayersByPosition(ctx context.Context, arg GetPlayersByPositionParams) ([]Player, error) {
	rows, err := q.db.Query(ctx, getPlayersByPosition, arg.Position, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Player{}
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.FirstName,
			&i.LastName,
			&i.FullName,
			&i.DateOfBirth,
			&i.Nationality,
			&i.Position,
			&i.ShirtNumber,
			&i.Height,
			&i.Weight,
			&i.PreferredFoot,
			&i.Photo,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayersByTeam = `-- name: GetPlayersByTeam :many
SELECT id, team_id, first_name, last_name, full_name, date_of_birth, nationality, position, shirt_number, height, weight, preferred_foot, photo, created_at, updated_at, deleted_at FROM players
WHERE team_id = $1 AND deleted_at IS NULL
ORDER BY shirt_number NULLS LAST, full_name
`

func (q *Queries) GetPlayersByTeam(ctx context.Context, teamID int32) ([]Player, error) {
	rows, err := q.db.Query(ctx, getPlayersByTeam, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Player{}
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.FirstName,
			&i.LastName,
			&i.FullName,
			&i.DateOfBirth,
			&i.Nationality,
			&i.Position,
			&i.ShirtNumber,
			&i.Height,
			&i.Weight,
			&i.PreferredFoot,
			&i.Photo,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlayers = `-- name: ListPlayers :many
SELECT id, team_id, first_name, last_name, full_name, date_of_birth, nationality, position, shirt_number, height, weight, preferred_foot, photo, created_at, updated_at, deleted_at FROM players
WHERE deleted_at IS NULL
ORDER BY full_name
LIMIT $1 OFFSET $2
`

type ListPlayersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPlayers(ctx context.Context, arg ListPlayersParams) ([]Player, error) {
	rows, err := q.db.Query(ctx, listPlayers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Player{}
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.FirstName,
			&i.LastName,
			&i.FullName,
			&i.DateOfBirth,
			&i.Nationality,
			&i.Position,
			&i.ShirtNumber,
			&i.Height,
			&i.Weight,
			&i.PreferredFoot,
			&i.Photo,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPlayersByName = `-- name: SearchPlayersByName :many
SELECT id, team_id, first_name, last_name, full_name, date_of_birth, nationality, position, shirt_number, height, weight, preferred_foot, photo, created_at, updated_at, deleted_at FROM players
WHERE deleted_at IS NULL
  AND full_name ILIKE '%' || $1 || '%'
ORDER BY full_name
LIMIT $2 OFFSET $3
`

type SearchPlayersByNameParams struct {
	Column1 *string `json:"column_1"`
	Limit   int32   `json:"limit"`
	Offset  int32   `json:"offset"`
}

func (q *Queries) SearchPlayersByName(ctx context.Context, arg SearchPlayersByNameParams) ([]Player, error) {
	rows, err := q.db.Query(ctx, searchPlayersByName, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Player{}
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.FirstName,
			&i.LastName,
			&i.FullName,
			&i.DateOfBirth,
			&i.Nationality,
			&i.Position,
			&i.ShirtNumber,
			&i.Height,
			&i.Weight,
			&i.PreferredFoot,
			&i.Photo,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlayer = `-- name: UpdatePlayer :one
UPDATE players
SET
    team_id = COALESCE($1, team_id),
    first_name = COALESCE($2, first_name),
    last_name = COALESCE($3, last_name),
    full_name = COALESCE($4, full_name),
    date_of_birth = COALESCE($5, date_of_birth),
    nationality = COALESCE($6, nationality),
    position = COALESCE($7, position),
    shirt_number = COALESCE($8, shirt_number),
    height = COALESCE($9, height),
    weight = COALESCE($10, weight),
    preferred_foot = COALESCE($11, preferred_foot),
    photo = COALESCE($12, photo)
WHERE id = $13 AND deleted_at IS NULL
RETURNING id, team_id, first_name, last_name, full_name, date_of_birth, nationality, position, shirt_number, height, weight, preferred_foot, photo, created_at, updated_at, deleted_at
`

type UpdatePlayerParams struct {
	TeamID        *int32      `json:"team_id"`
	FirstName     *string     `json:"first_name"`
	LastName      *string     `json:"last_name"`
	FullName      *string     `json:"full_name"`
	DateOfBirth   pgtype.Date `json:"date_of_birth"`
	Nationality   *string     `json:"nationality"`
	Position      *string     `json:"position"`
	ShirtNumber   *int32      `json:"shirt_number"`
	Height        *int32      `json:"height"`
	Weight        *int32      `json:"weight"`
	PreferredFoot *string     `json:"preferred_foot"`
	Photo         *string     `json:"photo"`
	ID            int32       `json:"id"`
}

func (q *Queries) UpdatePlayer(ctx context.Context, arg UpdatePlayerParams) (Player, error) {
	row := q.db.QueryRow(ctx, updatePlayer,
		arg.TeamID,
		arg.FirstName,
		arg.LastName,
		arg.FullName,
		arg.DateOfBirth,
		arg.Nationality,
		arg.Position,
		arg.ShirtNumber,
		arg.Height,
		arg.Weight,
		arg.PreferredFoot,
		arg.Photo,
		arg.ID,
	)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.FirstName,
		&i.LastName,
		&i.FullName,
		&i.DateOfBirth,
		&i.Nationality,
		&i.Position,
		&i.ShirtNumber,
		&i.Height,
		&i.Weight,
		&i.PreferredFoot,
		&i.Photo,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
