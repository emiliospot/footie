// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: match_events.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEventsByType = `-- name: CountEventsByType :one
SELECT COUNT(*) FROM match_events
WHERE match_id = $1 AND event_type = $2 AND deleted_at IS NULL
`

type CountEventsByTypeParams struct {
	MatchID   int32  `json:"match_id"`
	EventType string `json:"event_type"`
}

func (q *Queries) CountEventsByType(ctx context.Context, arg CountEventsByTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countEventsByType, arg.MatchID, arg.EventType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMatchEvents = `-- name: CountMatchEvents :one
SELECT COUNT(*) FROM match_events
WHERE match_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountMatchEvents(ctx context.Context, matchID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countMatchEvents, matchID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMatchEvent = `-- name: CreateMatchEvent :one
INSERT INTO match_events (
    match_id, team_id, player_id, secondary_player_id, event_type,
    minute, second, period, extra_minute, position_x, position_y, description, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
RETURNING id, match_id, team_id, player_id, secondary_player_id, event_type, minute, extra_minute, position_x, position_y, description, metadata, created_at, updated_at, deleted_at, second, period
`

type CreateMatchEventParams struct {
	MatchID           int32          `json:"match_id"`
	TeamID            *int32         `json:"team_id"`
	PlayerID          *int32         `json:"player_id"`
	SecondaryPlayerID *int32         `json:"secondary_player_id"`
	EventType         string         `json:"event_type"`
	Minute            int32          `json:"minute"`
	Second            *int32         `json:"second"`
	Period            *string        `json:"period"`
	ExtraMinute       *int32         `json:"extra_minute"`
	PositionX         pgtype.Numeric `json:"position_x"`
	PositionY         pgtype.Numeric `json:"position_y"`
	Description       *string        `json:"description"`
	Metadata          []byte         `json:"metadata"`
}

func (q *Queries) CreateMatchEvent(ctx context.Context, arg CreateMatchEventParams) (MatchEvent, error) {
	row := q.db.QueryRow(ctx, createMatchEvent,
		arg.MatchID,
		arg.TeamID,
		arg.PlayerID,
		arg.SecondaryPlayerID,
		arg.EventType,
		arg.Minute,
		arg.Second,
		arg.Period,
		arg.ExtraMinute,
		arg.PositionX,
		arg.PositionY,
		arg.Description,
		arg.Metadata,
	)
	var i MatchEvent
	err := row.Scan(
		&i.ID,
		&i.MatchID,
		&i.TeamID,
		&i.PlayerID,
		&i.SecondaryPlayerID,
		&i.EventType,
		&i.Minute,
		&i.ExtraMinute,
		&i.PositionX,
		&i.PositionY,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Second,
		&i.Period,
	)
	return i, err
}

const deleteMatchEvent = `-- name: DeleteMatchEvent :exec
UPDATE match_events
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteMatchEvent(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteMatchEvent, id)
	return err
}

const getCardsByMatch = `-- name: GetCardsByMatch :many
SELECT id, match_id, team_id, player_id, secondary_player_id, event_type, minute, extra_minute, position_x, position_y, description, metadata, created_at, updated_at, deleted_at, second, period FROM match_events
WHERE match_id = $1
  AND event_type IN ('yellow_card', 'red_card')
  AND deleted_at IS NULL
ORDER BY minute ASC, extra_minute ASC
`

func (q *Queries) GetCardsByMatch(ctx context.Context, matchID int32) ([]MatchEvent, error) {
	rows, err := q.db.Query(ctx, getCardsByMatch, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MatchEvent{}
	for rows.Next() {
		var i MatchEvent
		if err := rows.Scan(
			&i.ID,
			&i.MatchID,
			&i.TeamID,
			&i.PlayerID,
			&i.SecondaryPlayerID,
			&i.EventType,
			&i.Minute,
			&i.ExtraMinute,
			&i.PositionX,
			&i.PositionY,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Second,
			&i.Period,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGoalsByMatch = `-- name: GetGoalsByMatch :many
SELECT id, match_id, team_id, player_id, secondary_player_id, event_type, minute, extra_minute, position_x, position_y, description, metadata, created_at, updated_at, deleted_at, second, period FROM match_events
WHERE match_id = $1 AND event_type = 'goal' AND deleted_at IS NULL
ORDER BY minute ASC, extra_minute ASC
`

func (q *Queries) GetGoalsByMatch(ctx context.Context, matchID int32) ([]MatchEvent, error) {
	rows, err := q.db.Query(ctx, getGoalsByMatch, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MatchEvent{}
	for rows.Next() {
		var i MatchEvent
		if err := rows.Scan(
			&i.ID,
			&i.MatchID,
			&i.TeamID,
			&i.PlayerID,
			&i.SecondaryPlayerID,
			&i.EventType,
			&i.Minute,
			&i.ExtraMinute,
			&i.PositionX,
			&i.PositionY,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Second,
			&i.Period,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchEventByID = `-- name: GetMatchEventByID :one
SELECT id, match_id, team_id, player_id, secondary_player_id, event_type, minute, extra_minute, position_x, position_y, description, metadata, created_at, updated_at, deleted_at, second, period FROM match_events
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetMatchEventByID(ctx context.Context, id int32) (MatchEvent, error) {
	row := q.db.QueryRow(ctx, getMatchEventByID, id)
	var i MatchEvent
	err := row.Scan(
		&i.ID,
		&i.MatchID,
		&i.TeamID,
		&i.PlayerID,
		&i.SecondaryPlayerID,
		&i.EventType,
		&i.Minute,
		&i.ExtraMinute,
		&i.PositionX,
		&i.PositionY,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Second,
		&i.Period,
	)
	return i, err
}

const getMatchEvents = `-- name: GetMatchEvents :many
SELECT id, match_id, team_id, player_id, secondary_player_id, event_type, minute, extra_minute, position_x, position_y, description, metadata, created_at, updated_at, deleted_at, second, period FROM match_events
WHERE match_id = $1 AND deleted_at IS NULL
ORDER BY minute ASC, extra_minute ASC, id ASC
`

func (q *Queries) GetMatchEvents(ctx context.Context, matchID int32) ([]MatchEvent, error) {
	rows, err := q.db.Query(ctx, getMatchEvents, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MatchEvent{}
	for rows.Next() {
		var i MatchEvent
		if err := rows.Scan(
			&i.ID,
			&i.MatchID,
			&i.TeamID,
			&i.PlayerID,
			&i.SecondaryPlayerID,
			&i.EventType,
			&i.Minute,
			&i.ExtraMinute,
			&i.PositionX,
			&i.PositionY,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Second,
			&i.Period,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchEventsByType = `-- name: GetMatchEventsByType :many
SELECT id, match_id, team_id, player_id, secondary_player_id, event_type, minute, extra_minute, position_x, position_y, description, metadata, created_at, updated_at, deleted_at, second, period FROM match_events
WHERE match_id = $1 AND event_type = $2 AND deleted_at IS NULL
ORDER BY minute ASC, extra_minute ASC
`

type GetMatchEventsByTypeParams struct {
	MatchID   int32  `json:"match_id"`
	EventType string `json:"event_type"`
}

func (q *Queries) GetMatchEventsByType(ctx context.Context, arg GetMatchEventsByTypeParams) ([]MatchEvent, error) {
	rows, err := q.db.Query(ctx, getMatchEventsByType, arg.MatchID, arg.EventType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MatchEvent{}
	for rows.Next() {
		var i MatchEvent
		if err := rows.Scan(
			&i.ID,
			&i.MatchID,
			&i.TeamID,
			&i.PlayerID,
			&i.SecondaryPlayerID,
			&i.EventType,
			&i.Minute,
			&i.ExtraMinute,
			&i.PositionX,
			&i.PositionY,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Second,
			&i.Period,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPassesByMatch = `-- name: GetPassesByMatch :many
SELECT id, match_id, team_id, player_id, secondary_player_id, event_type, minute, extra_minute, position_x, position_y, description, metadata, created_at, updated_at, deleted_at, second, period FROM match_events
WHERE match_id = $1 AND event_type = 'pass' AND deleted_at IS NULL
ORDER BY minute ASC, extra_minute ASC
`

func (q *Queries) GetPassesByMatch(ctx context.Context, matchID int32) ([]MatchEvent, error) {
	rows, err := q.db.Query(ctx, getPassesByMatch, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MatchEvent{}
	for rows.Next() {
		var i MatchEvent
		if err := rows.Scan(
			&i.ID,
			&i.MatchID,
			&i.TeamID,
			&i.PlayerID,
			&i.SecondaryPlayerID,
			&i.EventType,
			&i.Minute,
			&i.ExtraMinute,
			&i.PositionX,
			&i.PositionY,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Second,
			&i.Period,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerEvents = `-- name: GetPlayerEvents :many
SELECT id, match_id, team_id, player_id, secondary_player_id, event_type, minute, extra_minute, position_x, position_y, description, metadata, created_at, updated_at, deleted_at, second, period FROM match_events
WHERE player_id = $1 AND deleted_at IS NULL
ORDER BY id DESC
LIMIT $2 OFFSET $3
`

type GetPlayerEventsParams struct {
	PlayerID *int32 `json:"player_id"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) GetPlayerEvents(ctx context.Context, arg GetPlayerEventsParams) ([]MatchEvent, error) {
	rows, err := q.db.Query(ctx, getPlayerEvents, arg.PlayerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MatchEvent{}
	for rows.Next() {
		var i MatchEvent
		if err := rows.Scan(
			&i.ID,
			&i.MatchID,
			&i.TeamID,
			&i.PlayerID,
			&i.SecondaryPlayerID,
			&i.EventType,
			&i.Minute,
			&i.ExtraMinute,
			&i.PositionX,
			&i.PositionY,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Second,
			&i.Period,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerPassAccuracy = `-- name: GetPlayerPassAccuracy :one
SELECT
    COUNT(*) FILTER (WHERE metadata->>'completed' = 'true') as completed_passes,
    COUNT(*) as total_passes,
    CASE
        WHEN COUNT(*) > 0 THEN
            ROUND((COUNT(*) FILTER (WHERE metadata->>'completed' = 'true')::numeric / COUNT(*) * 100), 2)
        ELSE 0
    END as pass_accuracy_percentage
FROM match_events
WHERE player_id = $1
  AND event_type = 'pass'
  AND deleted_at IS NULL
`

type GetPlayerPassAccuracyRow struct {
	CompletedPasses        int64 `json:"completed_passes"`
	TotalPasses            int64 `json:"total_passes"`
	PassAccuracyPercentage int32 `json:"pass_accuracy_percentage"`
}

func (q *Queries) GetPlayerPassAccuracy(ctx context.Context, playerID *int32) (GetPlayerPassAccuracyRow, error) {
	row := q.db.QueryRow(ctx, getPlayerPassAccuracy, playerID)
	var i GetPlayerPassAccuracyRow
	err := row.Scan(&i.CompletedPasses, &i.TotalPasses, &i.PassAccuracyPercentage)
	return i, err
}

const getPlayerShotsWithXG = `-- name: GetPlayerShotsWithXG :many
SELECT
    me.id, me.match_id, me.team_id, me.player_id, me.secondary_player_id, me.event_type, me.minute, me.extra_minute, me.position_x, me.position_y, me.description, me.metadata, me.created_at, me.updated_at, me.deleted_at, me.second, me.period,
    me.metadata->>'xg' as expected_goals,
    me.metadata->>'shot_type' as shot_type,
    me.metadata->>'body_part' as body_part
FROM match_events me
WHERE me.player_id = $1
  AND me.event_type = 'shot'
  AND me.deleted_at IS NULL
ORDER BY me.id DESC
LIMIT $2 OFFSET $3
`

type GetPlayerShotsWithXGParams struct {
	PlayerID *int32 `json:"player_id"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

type GetPlayerShotsWithXGRow struct {
	ID                int32              `json:"id"`
	MatchID           int32              `json:"match_id"`
	TeamID            *int32             `json:"team_id"`
	PlayerID          *int32             `json:"player_id"`
	SecondaryPlayerID *int32             `json:"secondary_player_id"`
	EventType         string             `json:"event_type"`
	Minute            int32              `json:"minute"`
	ExtraMinute       *int32             `json:"extra_minute"`
	PositionX         pgtype.Numeric     `json:"position_x"`
	PositionY         pgtype.Numeric     `json:"position_y"`
	Description       *string            `json:"description"`
	Metadata          []byte             `json:"metadata"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
	Second            *int32             `json:"second"`
	Period            *string            `json:"period"`
	ExpectedGoals     interface{}        `json:"expected_goals"`
	ShotType          interface{}        `json:"shot_type"`
	BodyPart          interface{}        `json:"body_part"`
}

// Analytics queries for match events
func (q *Queries) GetPlayerShotsWithXG(ctx context.Context, arg GetPlayerShotsWithXGParams) ([]GetPlayerShotsWithXGRow, error) {
	rows, err := q.db.Query(ctx, getPlayerShotsWithXG, arg.PlayerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPlayerShotsWithXGRow{}
	for rows.Next() {
		var i GetPlayerShotsWithXGRow
		if err := rows.Scan(
			&i.ID,
			&i.MatchID,
			&i.TeamID,
			&i.PlayerID,
			&i.SecondaryPlayerID,
			&i.EventType,
			&i.Minute,
			&i.ExtraMinute,
			&i.PositionX,
			&i.PositionY,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Second,
			&i.Period,
			&i.ExpectedGoals,
			&i.ShotType,
			&i.BodyPart,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShotsByMatch = `-- name: GetShotsByMatch :many
SELECT id, match_id, team_id, player_id, secondary_player_id, event_type, minute, extra_minute, position_x, position_y, description, metadata, created_at, updated_at, deleted_at, second, period FROM match_events
WHERE match_id = $1 AND event_type = 'shot' AND deleted_at IS NULL
ORDER BY minute ASC, extra_minute ASC
`

func (q *Queries) GetShotsByMatch(ctx context.Context, matchID int32) ([]MatchEvent, error) {
	rows, err := q.db.Query(ctx, getShotsByMatch, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MatchEvent{}
	for rows.Next() {
		var i MatchEvent
		if err := rows.Scan(
			&i.ID,
			&i.MatchID,
			&i.TeamID,
			&i.PlayerID,
			&i.SecondaryPlayerID,
			&i.EventType,
			&i.Minute,
			&i.ExtraMinute,
			&i.PositionX,
			&i.PositionY,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Second,
			&i.Period,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamEventsInMatch = `-- name: GetTeamEventsInMatch :many
SELECT id, match_id, team_id, player_id, secondary_player_id, event_type, minute, extra_minute, position_x, position_y, description, metadata, created_at, updated_at, deleted_at, second, period FROM match_events
WHERE match_id = $1 AND team_id = $2 AND deleted_at IS NULL
ORDER BY minute ASC, extra_minute ASC
`

type GetTeamEventsInMatchParams struct {
	MatchID int32  `json:"match_id"`
	TeamID  *int32 `json:"team_id"`
}

func (q *Queries) GetTeamEventsInMatch(ctx context.Context, arg GetTeamEventsInMatchParams) ([]MatchEvent, error) {
	rows, err := q.db.Query(ctx, getTeamEventsInMatch, arg.MatchID, arg.TeamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MatchEvent{}
	for rows.Next() {
		var i MatchEvent
		if err := rows.Scan(
			&i.ID,
			&i.MatchID,
			&i.TeamID,
			&i.PlayerID,
			&i.SecondaryPlayerID,
			&i.EventType,
			&i.Minute,
			&i.ExtraMinute,
			&i.PositionX,
			&i.PositionY,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Second,
			&i.Period,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamPossessionEvents = `-- name: GetTeamPossessionEvents :many
SELECT
    team_id,
    COUNT(*) as total_events,
    COUNT(*) FILTER (WHERE event_type = 'pass') as passes,
    COUNT(*) FILTER (WHERE event_type = 'shot') as shots
FROM match_events
WHERE match_id = $1 AND deleted_at IS NULL
GROUP BY team_id
`

type GetTeamPossessionEventsRow struct {
	TeamID      *int32 `json:"team_id"`
	TotalEvents int64  `json:"total_events"`
	Passes      int64  `json:"passes"`
	Shots       int64  `json:"shots"`
}

func (q *Queries) GetTeamPossessionEvents(ctx context.Context, matchID int32) ([]GetTeamPossessionEventsRow, error) {
	rows, err := q.db.Query(ctx, getTeamPossessionEvents, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTeamPossessionEventsRow{}
	for rows.Next() {
		var i GetTeamPossessionEventsRow
		if err := rows.Scan(
			&i.TeamID,
			&i.TotalEvents,
			&i.Passes,
			&i.Shots,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMatchEvent = `-- name: UpdateMatchEvent :one
UPDATE match_events
SET
    event_type = COALESCE($1, event_type),
    minute = COALESCE($2, minute),
    extra_minute = COALESCE($3, extra_minute),
    position_x = COALESCE($4, position_x),
    position_y = COALESCE($5, position_y),
    description = COALESCE($6, description),
    metadata = COALESCE($7, metadata)
WHERE id = $8 AND deleted_at IS NULL
RETURNING id, match_id, team_id, player_id, secondary_player_id, event_type, minute, extra_minute, position_x, position_y, description, metadata, created_at, updated_at, deleted_at, second, period
`

type UpdateMatchEventParams struct {
	EventType   *string        `json:"event_type"`
	Minute      *int32         `json:"minute"`
	ExtraMinute *int32         `json:"extra_minute"`
	PositionX   pgtype.Numeric `json:"position_x"`
	PositionY   pgtype.Numeric `json:"position_y"`
	Description *string        `json:"description"`
	Metadata    []byte         `json:"metadata"`
	ID          int32          `json:"id"`
}

func (q *Queries) UpdateMatchEvent(ctx context.Context, arg UpdateMatchEventParams) (MatchEvent, error) {
	row := q.db.QueryRow(ctx, updateMatchEvent,
		arg.EventType,
		arg.Minute,
		arg.ExtraMinute,
		arg.PositionX,
		arg.PositionY,
		arg.Description,
		arg.Metadata,
		arg.ID,
	)
	var i MatchEvent
	err := row.Scan(
		&i.ID,
		&i.MatchID,
		&i.TeamID,
		&i.PlayerID,
		&i.SecondaryPlayerID,
		&i.EventType,
		&i.Minute,
		&i.ExtraMinute,
		&i.PositionX,
		&i.PositionY,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Second,
		&i.Period,
	)
	return i, err
}
