// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: teams.sql

package sqlc

import (
	"context"
)

const countTeams = `-- name: CountTeams :one
SELECT COUNT(*) FROM teams
WHERE deleted_at IS NULL
`

func (q *Queries) CountTeams(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countTeams)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTeam = `-- name: CreateTeam :one
INSERT INTO teams (
    name, short_name, code, country, city, stadium, stadium_capacity,
    founded, logo, colors, website
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
RETURNING id, name, short_name, code, country, city, stadium, stadium_capacity, founded, logo, colors, website, created_at, updated_at, deleted_at
`

type CreateTeamParams struct {
	Name            string  `json:"name"`
	ShortName       string  `json:"short_name"`
	Code            string  `json:"code"`
	Country         string  `json:"country"`
	City            *string `json:"city"`
	Stadium         *string `json:"stadium"`
	StadiumCapacity *int32  `json:"stadium_capacity"`
	Founded         *int32  `json:"founded"`
	Logo            *string `json:"logo"`
	Colors          *string `json:"colors"`
	Website         *string `json:"website"`
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (Team, error) {
	row := q.db.QueryRow(ctx, createTeam,
		arg.Name,
		arg.ShortName,
		arg.Code,
		arg.Country,
		arg.City,
		arg.Stadium,
		arg.StadiumCapacity,
		arg.Founded,
		arg.Logo,
		arg.Colors,
		arg.Website,
	)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ShortName,
		&i.Code,
		&i.Country,
		&i.City,
		&i.Stadium,
		&i.StadiumCapacity,
		&i.Founded,
		&i.Logo,
		&i.Colors,
		&i.Website,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteTeam = `-- name: DeleteTeam :exec
UPDATE teams
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteTeam(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteTeam, id)
	return err
}

const getTeamByCode = `-- name: GetTeamByCode :one
SELECT id, name, short_name, code, country, city, stadium, stadium_capacity, founded, logo, colors, website, created_at, updated_at, deleted_at FROM teams
WHERE code = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetTeamByCode(ctx context.Context, code string) (Team, error) {
	row := q.db.QueryRow(ctx, getTeamByCode, code)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ShortName,
		&i.Code,
		&i.Country,
		&i.City,
		&i.Stadium,
		&i.StadiumCapacity,
		&i.Founded,
		&i.Logo,
		&i.Colors,
		&i.Website,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getTeamByID = `-- name: GetTeamByID :one
SELECT id, name, short_name, code, country, city, stadium, stadium_capacity, founded, logo, colors, website, created_at, updated_at, deleted_at FROM teams
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetTeamByID(ctx context.Context, id int32) (Team, error) {
	row := q.db.QueryRow(ctx, getTeamByID, id)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ShortName,
		&i.Code,
		&i.Country,
		&i.City,
		&i.Stadium,
		&i.StadiumCapacity,
		&i.Founded,
		&i.Logo,
		&i.Colors,
		&i.Website,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getTeamsByCountry = `-- name: GetTeamsByCountry :many
SELECT id, name, short_name, code, country, city, stadium, stadium_capacity, founded, logo, colors, website, created_at, updated_at, deleted_at FROM teams
WHERE country = $1 AND deleted_at IS NULL
ORDER BY name
`

func (q *Queries) GetTeamsByCountry(ctx context.Context, country string) ([]Team, error) {
	rows, err := q.db.Query(ctx, getTeamsByCountry, country)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ShortName,
			&i.Code,
			&i.Country,
			&i.City,
			&i.Stadium,
			&i.StadiumCapacity,
			&i.Founded,
			&i.Logo,
			&i.Colors,
			&i.Website,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeams = `-- name: ListTeams :many
SELECT id, name, short_name, code, country, city, stadium, stadium_capacity, founded, logo, colors, website, created_at, updated_at, deleted_at FROM teams
WHERE deleted_at IS NULL
ORDER BY name
LIMIT $1 OFFSET $2
`

type ListTeamsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListTeams(ctx context.Context, arg ListTeamsParams) ([]Team, error) {
	rows, err := q.db.Query(ctx, listTeams, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ShortName,
			&i.Code,
			&i.Country,
			&i.City,
			&i.Stadium,
			&i.StadiumCapacity,
			&i.Founded,
			&i.Logo,
			&i.Colors,
			&i.Website,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTeamsByName = `-- name: SearchTeamsByName :many
SELECT id, name, short_name, code, country, city, stadium, stadium_capacity, founded, logo, colors, website, created_at, updated_at, deleted_at FROM teams
WHERE deleted_at IS NULL
  AND name ILIKE '%' || $1 || '%'
ORDER BY name
LIMIT $2 OFFSET $3
`

type SearchTeamsByNameParams struct {
	Column1 *string `json:"column_1"`
	Limit   int32   `json:"limit"`
	Offset  int32   `json:"offset"`
}

func (q *Queries) SearchTeamsByName(ctx context.Context, arg SearchTeamsByNameParams) ([]Team, error) {
	rows, err := q.db.Query(ctx, searchTeamsByName, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ShortName,
			&i.Code,
			&i.Country,
			&i.City,
			&i.Stadium,
			&i.StadiumCapacity,
			&i.Founded,
			&i.Logo,
			&i.Colors,
			&i.Website,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTeam = `-- name: UpdateTeam :one
UPDATE teams
SET
    name = COALESCE($1, name),
    short_name = COALESCE($2, short_name),
    country = COALESCE($3, country),
    city = COALESCE($4, city),
    stadium = COALESCE($5, stadium),
    stadium_capacity = COALESCE($6, stadium_capacity),
    logo = COALESCE($7, logo),
    colors = COALESCE($8, colors),
    website = COALESCE($9, website)
WHERE id = $10 AND deleted_at IS NULL
RETURNING id, name, short_name, code, country, city, stadium, stadium_capacity, founded, logo, colors, website, created_at, updated_at, deleted_at
`

type UpdateTeamParams struct {
	Name            *string `json:"name"`
	ShortName       *string `json:"short_name"`
	Country         *string `json:"country"`
	City            *string `json:"city"`
	Stadium         *string `json:"stadium"`
	StadiumCapacity *int32  `json:"stadium_capacity"`
	Logo            *string `json:"logo"`
	Colors          *string `json:"colors"`
	Website         *string `json:"website"`
	ID              int32   `json:"id"`
}

func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) (Team, error) {
	row := q.db.QueryRow(ctx, updateTeam,
		arg.Name,
		arg.ShortName,
		arg.Country,
		arg.City,
		arg.Stadium,
		arg.StadiumCapacity,
		arg.Logo,
		arg.Colors,
		arg.Website,
		arg.ID,
	)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ShortName,
		&i.Code,
		&i.Country,
		&i.City,
		&i.Stadium,
		&i.StadiumCapacity,
		&i.Founded,
		&i.Logo,
		&i.Colors,
		&i.Website,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
